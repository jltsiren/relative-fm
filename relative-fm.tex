\documentclass[11pt,a4paper]{article}
\usepackage{fullpage}
%\parindent = 0ex

\newcommand{\Oh}[1]
  {\ensuremath{\mathcal{O}\!\left( {#1} \right)}}
\newcommand{\BWT}
  {\ensuremath{\mathsf{BWT}}}
\newcommand{\SA}
  {\ensuremath{\mathsf{SA}}}
\newcommand{\LCP}
  {\ensuremath{\mathsf{LCP}}}
\newcommand{\LCS}
  {\ensuremath{\mathsf{LCS}}}

\newcommand{\mrank}{\ensuremath{\mathsf{rank}}}
\newcommand{\mselect}{\ensuremath{\mathsf{select}}}

\begin{document}

\title{Relative FM-index}
\author{Jouni Sir\'en}
\maketitle

\section*{Computing $\mrank_{c}(\BWT(S'), i)$}

Let $\LCS_{B} = \LCS(\BWT(S), \BWT(S'))$. We have the following structures:
\begin{enumerate}
\item Bitvector $B_{B}$ marking $\LCS_{B}$ in $\BWT(S)$.
\item Bitvector $B_{B}'$ marking $\LCS_{B}$ in $\BWT(S')$.
\item Sequence $\overline{\LCS_{B}}$ containing the complement of $\LCS_{B}$ in $\BWT(S)$.
\item Sequence $\overline{\LCS_{B}'}$ containing the complement of $\LCS_{B}$ in $\BWT(S')$.
\end{enumerate}

Let $j = \mrank_{1}(B_{B}', i)$. Then $\mrank_{c}(\BWT(S'), i) = \mrank_{c}(\LCS_{B}, j) + \mrank_{c}(\overline{\LCS_{B}'}, i-j).$ To compute $\mrank_{c}(\LCS_{B}, j)$, we first determine $k = \mselect_{1}(B_{B}, j)$. Then $\mrank_{c}(\LCS_{B}, j) = \mrank_{c}(\BWT(S), k) - \mrank_{c}(\overline{\LCS_{B}}, k-j)$.

% This may be a bit faster in practice, but let's not confuse things with it.
%Instead of storing sequence $\overline{\LCS_{B}}$, we can use bitvector $B_{LF}$ marking $\LCS_{B}$ in column $F$ (we have $B_{LF}[LF_{S}(k)] = B_{B}[k]$). Then
%$$
%\mrank_{c}(\LCS_{B}, j) =
%LF_{\LCS}(j) - C_{\LCS}[c] =
%\mrank_{1}(B_{LF}, LF_{S}(k)) - \mrank_{1}(B_{LF}, C_{S}[c]).
%$$


\section*{Direct construction}

Assume that we have $\BWT(S)$, the inverse suffix array samples used for computing $\SA(S)^{-1}$, and an alignment of $S$ and $S'$. With these structures, we can build the relative FM-index for $S'$ directly. We start by building bitvectors $B_{A}$ and $B_{A}'$ that mark the non-gap characters of $S$ and $S'$ in the alignment, respectively. Then we scan the alignment from right to left, starting from the common endmarker.

In the following, $p$ denotes a position in the alignment. Positions $i$ and $i'$ are the corresponding positions in $S$ and $S'$, which can be determined by $\mrank$ operations on bitvectors $B_{A}$ and $B_{A}'$. We use shorthands $c = S[i]$ and $c' = S'[i']$ for the current characters. Values $j$ and $j'$ are the lexicographic ranks of the current suffixes of $S$ and $S'$. Arrays $M$ and $M'$ are used for building the relative FM-index. For each position $p$, we do the following.

\begin{enumerate}

\item We are in a common segment.
\begin{enumerate}
\item If neither sequence has a gap and $c = c'$, we do nothing.
\item Otherwise we determine $j = j' = \SA(S)^{-1}[i + 1]$ and continue to the divergent case.
\end{enumerate}

\item We are in a divergent segment. We update $j$ and $j'$ by backward searching: $j \leftarrow C[c] + \mrank_{c}(\BWT(S), j)$ and $j' \leftarrow C[c'] + \mrank_{c'}(\BWT(S), j')$, unless the character is a gap.
\begin{enumerate}
\item If neither sequence has a gap, $c = c'$, and $j = j'$, we do nothing, as we have returned to a common segment.
\item If $S'$ has a gap, we add $(j, S[i-1])$ to $M$.\label{case:deletion}
\item If $S$ has a gap, we add $(i', c', j', S'[i'-1])$ to $M'$. If $M'$ does not contain position $i'+1$, we add an endmarker corresponding to that position as well, but use a null value as the fourth component.\footnote{See my PhD thesis, section 5.3, for details on handling the endmarkers.}\label{case:insertion}
\item Otherwise we do both \ref{case:deletion} and \ref{case:insertion}.
\end{enumerate}

\end{enumerate}

Sequence $\overline{\LCS_{B}}$ and bitvector $B_{B}$ can be obtained by sorting $M$ by component $j$. To obtain $\overline{\LCS_{B}'}$ and $B_{B}'$, we start by sorting $M'$ by component $i'$. Then we build $\SA(M')$ by using the sums $c'+j'$ as character values. Sequence $\overline{\LCS_{B}'}$ is obtained by scanning $M'$ in suffix array order and concatenating components $S'[i'-1]$, ignoring the guards with null values. Bitvector $B_{B}'$ can be obtained from $B_{B}$ and components $j'$, ignoring the guards again.

\iffalse

\section*{Reusing suffix array samples}

Let $\LCS_{S} = \LCS(S, S')$, and let bitvector $B$ mark the sampled positions in $\SA(S)$. We need the following additional structures structures:
\begin{enumerate}
\item Bitvector $B'$ marking sampled positions in $\SA(S')$. It would be nice if we did not need this.
\item Permutation $\pi$ for reordering the reused samples. What is a good way to store this? Simple run-length encoding?
\item Bitvector $B_{R}$ such that $B_{R}[\mrank_{1}(B, i)] = 1$ iff $\SA(S)[i]$ is a reused sample. Reused samples are all located in $\LCS_{S}$.
\item Bitvector $B_{S}$ marking $\LCS_{S}$ in $S$.
\item Bitvector $B_{S}'$ marking $\LCS_{S}$ in $S'$.
\item Bitvector $B_{T}$ marking reused samples of $S$ in text order.
\end{enumerate}

Assume that $B'[i] = 1$. We want to retrieve reused sample $\pi(\mrank_{1}(B', i))$, which is sample $\mselect_{1}(B_{R}, \pi(\mrank_{1}(B', i)))$ of $S$. Let $j$ be the sampled text position in $S$. The corresponding position in $S'$ is $\mselect_{1}(B_{S}', \mrank_{1}(B_{S}, j))$.

Assume now that we want to find the first inverse sample after text position $b'$ in $S'$ (e.g.~to extract substring $S'[a',b']$). The corresponding position in $S$ is $b = \mselect_{1}(B_{S}, \mrank_{1}(B_{S}', b') + 1 - B_{S}'[b'])$, and the first sample after that is $\mselect_{1}(B_{T}, \mrank_{1}(B_{T}, \lceil b/d \rceil) + 1 - B_{T}[\lceil b/d \rceil])$, where $d$ is the sample density. Let $i$ be the same sample in suffix array order, and let $j$ be the value of that sample. We convert it to suffix array position $\mselect_{1}(B', \pi^{-1}(\mrank_{1}(B_{R}, i)))$ and text position $\mselect_{1}(B_{S}', \mrank_{1}(B_{S}, j))$.

\fi

\end{document}